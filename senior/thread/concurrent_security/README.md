# 并发安全和锁


## 1、案例分析
&emsp;&emsp;运行案例中的程序会导致结果不是x的结果，产生这种问题的原因是因为这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。

解决办法：添加锁


## 2、读写锁
### 2.1、读写锁的作用：
&emsp;&emsp;互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。

### 2.2、读写锁分为两种：
1. 当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；
2. 当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。


## 3、互斥锁
&emsp;&emsp;互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：

### 3.1、读写锁的作用：
&emsp;&emsp;使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。

